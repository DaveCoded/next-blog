---
title: 'Yeah, Linus already thought of that'
subtitle: "Don't know when a bug was introduced? Use <code>git bisect</code>"
description:
  'A story about hunting down a bug in production and how much easier it would have been
  if I had known about git bisect.'
excerpt: ''
date: '04/26/22'
status: 'draft'
tags: ['git']
keywords:
  'git, git bisect, bug in production, Linus Torvalds, divide and conquer, binary search'
completion: 'spark'
---

## Bugs happen

<p>
  <Dropcap>Until</Dropcap> no people are involved in the process, writing software will
  always produce bugs. Many are preventable with good practices and checks in place. Many
  can be caught by automated tests or a rigorous QA team before they are released and
  cause any great damage. But there will always be some that escape us, making their way
  into production.
</p>

## Bugs can hide under rocks

Once we know we have a bug, it is often reasonably obvious what piece of code is causing
an issue. Though fixing it will usually be an entirely more difficult
proposition.<MarginNote id={1}>Otherwise you would have done it perfectly the first time,
right?</MarginNote>

But this is not always the case. Code is interconnected and our codebases can become
complexly intertwined. Adding a new feature might require refactoring existing code. Or a
large refactor might be made to ease progress more generally. Some new code might reuse an
existing function that worked perfectly for all previous use cases, but this new use shows
that it was buggy all along.

It's no wonder then that a release can cause a bug in an area of an application that the
new code apparently didn't even touch. Cue glaze-eyed head-scratching.

## Send out the search party

But what do you do when a bug is found in your application and nobody can know how long
it's been there? If that seems improbable, let me detail some possible scenarios:

1. You work on an internal tool that has not yet been adopted by too many users.
2. The feedback chain between you and your users is broken: someone vital is on leave;
   insufficient process; given too low a priority; managers trying to shield you (take
   your pick).
3. Or more simply, the bug is a pretty rare edge case that will not be experienced by many
   users. And the first to report it is not necessarily the first to have experienced it.

In short, we are at the mercy of human error. So of course this will happen. When it
happened to me, it was a combination of scenarios 1 and 3. A feature that had been in the
application forever suddenly no longer worked. But when was the last time we knew it to be
working? We didn't know. The test cases we had didn't cover what had happened (a lesson in
itself).

## Apply a well-known algorithm

It was clear that the first step was to find the exact git commit that introduced the bug.
Lucky for me, fixing it was—though definitely a priority—not critical since no users had
noticed in however long it had been. That meant the panic was manageable enough that I
could take a breath and think.

How does a programmer find something? They use a search algorithm, of course. This seemed
to me like the perfect use-case for applying a binary search. I checked out an older
commit. The bug was still there. That meant it had been introduced before then even. I
checked out an even older commit. No bug. Good, now I had a range.

I'd cast my net wide so it was time to narrow it down. I wanted to check out a commit
halfway between the two: the older that didn't have the bug and the more recent that did.
Using the formatting arguments that can be passed to `git log` helped a huge amount here
as the defaults add too much noise in the terminal, spreading the commits so that they
can't easily be scanned. I used this from a helpful
[stack overflow article](https://stackoverflow.com/questions/21623699/is-it-possible-to-get-a-list-of-merges-into-a-branch-from-the-github-website-or):

```shell
git log --merges --first-parent master \
--pretty=format:"%h %<(10,trunc)%aN %C(white)%<(15)%ar%Creset %C(red bold)%<(15)%D%Creset %s"
```

This gave me all the merge commits into the master branch with the following information:

- Shortened commit hash
- Name of contributor
- How long ago the merge took place
- Commit message

And they were all displayed on their own line, which meant that scanning for a commit
halfway (roughly) between those I'd checked out previously was now a breeze. I was able to
progressively diminish the range of possible offending commits until, finally, I found the
commit I'd been looking for. It had been merged five months before!

## Know your tools

## How git bisect works

- Explain how `git bisect` does the same and show the basic commands. Link to the proper
  documentation or show how to pull up the `man` page for it.
- Show how to narrow down the selection of commits that you want to consider and credit
  Shiva Rajagopal for this great post: https://interrupt.memfault.com/blog/git-bisect
