---
title: 'Notes on Database Normalization'
subtitle: 'What is it? Why do we need it? How is it done?'
excerpt: "Research notes I'm making with a view to understanding the concept of database normalization."
description: "Research notes I'm making with a view to understanding the concept of database normalization."
date: '09/16/21'
status: 'draft'
tags: ['Databases']
---

## History

- "It was first proposed by Edgar F. Codd as part of his relational model." (wikipedia)

## What is database normalization?

- It concerns how we _structure_ a relational (usually) database
- The aim is to reduce data redundancy and to improve data integrity
- We do this by adhering to the "**normal forms**"

### Data redundancy

- Essentially the duplication of data in multiple records, either within a table or across multiple tables
- Can lead to corruption of data, or just increased storage requirements

### Data integrity

- Ensuring the persistence and retention of data

### 3 kinds of anomaly

There are three main dangers for databases that have not been normalized:

#### Update anomaly

- When you have the same data expressed in multiple places, they must be updated together
- Therefore, if for any reason an update is only partially successful, some records may update while others do not
- It is then possible to get two different answers to the same query

#### Insertion anomaly

- When you need to add a record to a table that can't because of the specified columns
- Wikipedia example gives faculty members as below:

<FacultyTable />

- Now imagine a new member starts, but is not yet teaching a course. Their Course Code
  would have to be given as `null`

#### Deletion anomaly

- This is when deleting data holding one fact necessarily deletes data holding another fact
- The Faculty Table suffers from this anomaly. If you delete a course, you will also delete
  the faculty member, unless the course code is set to `null`

### Principle: extensions should require minimal redesign

- You should be able to add new types of data to a database without changing its structure too much
- Each change in structure could potentially break existing applications that interact with the data

### The normal forms

#### 1NF

- Every cell value must contain only one balue
- All entries in the same column are of the same types
- Rows are uniquely identified (by adding a unique ID or enough columns that data is necessarily unique)

#### 2NF

- All attributes (columns that aren't keys) are dependent on the keys
- In other words, if you have a column or columns that are related to each other, or some other data,
  but not the primary key, then they belong in a different table

#### 3NF

- All columns/fields can be determined only by the key in the table, and not by any other column

#### 4NF

- No multi-valued dependencies
- Let's assume your primary key is a customer ID. What if that customers has multiple addresses?
  Or multiple credit cards? Multiple subscriptions?
- Rather than storing those _multi-valued dependencies_ on the Customer table, they can go in their
  own **address**, **credit_card** and **subscription** tables
- That way, we prevent obvious update anomalies
